'use strict';

const htmlparser = Npm.require('htmlparser2');
const sourcemap = Npm.require('source-map');
const svelte = Npm.require('svelte-es5-meteor');

Plugin.registerCompiler({
  extensions: ['html'],
}, () => new SvelteCompiler);

class SvelteCompiler {
  processFilesForTarget(files) {
    files.forEach(file => {
      this.processOneFileForTarget(file);
    });
  }

  processOneFileForTarget(file) {
    const raw = file.getContentsAsString();
    const path = file.getPathInPackage();

    let isSvelteComponent = true;

    // Search for top level head and body tags. If at least one of these tags
    // exists, the file is not processed using the Svelte compiler. Instead, the
    // inner HTML of the tags is added to the respective section in the HTML
    // output produced by Meteor.
    htmlparser.parseDOM(raw).forEach(el => {
      if (el.name === 'head' || el.name === 'body') {
        isSvelteComponent = false;

        file.addHtml({
          section: el.name,
          data: htmlparser.DomUtils.getInnerHTML(el)
        });
      }
    });

    if (!isSvelteComponent) {
      return;
    }

    try {
      const compiled = svelte.compile(raw, {
        filename: path,
        name: file.getBasename()
          .slice(0, -5) // Remove .html extension
          .replace(/[^a-z0-9_$]/ig, '_') // Ensure valid identifier
      });

      file.addJavaScript(this.transpileWithBabel(compiled, path));
    } catch (e) {
      // Throw unknown errors
      if (!e.loc) throw e;

      file.error({
        message: e.message,
        line: e.loc.line,
        column: e.loc.column
      });
    }
  }

  transpileWithBabel(source, path) {
    const options = Babel.getDefaultOptions();
    options.filename = path;
    options.sourceMap = true;

    const transpiled = Babel.compile(source.code, options);

    return {
      sourcePath: path,
      path,
      data: transpiled.code,
      sourceMap: this.combineSourceMaps(transpiled.map, source.map)
    };
  }

  // Generates a new source map that maps a file transpiled by Babel back to the
  // original HTML via a source map generated by the Svelte compiler
  combineSourceMaps(babelMap, svelteMap) {
    const result = new sourcemap.SourceMapGenerator;

    const babelConsumer = new sourcemap.SourceMapConsumer(babelMap);
    const svelteConsumer = new sourcemap.SourceMapConsumer(svelteMap);

    babelConsumer.eachMapping(mapping =>Â {
      const position = svelteConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });

      // Ignore mappings that don't map to the original HTML
      if (!position.source) {
        return;
      }

      result.addMapping({
        source: position.source,
        original: {
          line: position.line,
          column: position.column
        },
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      });
    });

    // Copy source content from the source map generated by the Svelte compiler.
    // We can just take the first entry because only one file is involved in the
    // Svelte compilation and Babel transpilation.
    result.setSourceContent(
      svelteMap.sources[0],
      svelteMap.sourcesContent[0]
    );

    return result.toJSON();
  }
}
